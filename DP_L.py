# 太郎君と次郎君が次のゲームで勝負します。
# 最初に、数列 a=(a1,a2,…,aN)が与えられます。
# aが空になるまで、二人は次の操作を交互に行います。
# 先手は太郎君です。
# aの先頭要素または末尾要素を取り除く。
# 取り除いた要素を x とすると、操作を行った人は x点を得る。
# ゲーム終了時の太郎君の総得点を X、次郎君の総得点を Y とします。
# 太郎君は X−Y を最大化しようとし、次郎君は X−Yを最小化しようとします。
# 二人が最適に行動すると仮定したとき、X−Yを求めてください。
# 入力はすべて整数である。
# 1≤N≤3000
# 1≤ai≤10^9

# わからん
# 思ったよりたくさんループが回るから漸化式が作れない
# dp[i] 
# 単純に考えたら2^3000個の計算が必要
# 難しいのはi番目の終了時点での最善が全体としての最善にならない可能性があること
# dp[i] 最後にaiを取ったときの最適行動による結果ならありかもしれない

# 太字で書いてあるところは要するに「(自分の点数)－(相手の点数)を最大化しようとする」だね！
# 前から取ったほうがいいか後ろから取ったほうがいいかは、残った数を使ってのゲームの結果が分かれば判断できるから、
# dp[i][j]=(区間[i,j]が残ってるときの「次の手番の人の得点－そうじゃない方の人の得点」)
# とすればよさそうだね。実装はメモ化再帰が簡単かな。

# 「以降のゲームの結果を利用して」とあるから再帰なんだろうけどちょっと苦手っぽいので一旦諦める

# def catch(i,b):
#     if len(b) == 0:
#         pass
#     else:
#         catch(i+1,b)
def solve(N,a):
    # dp = [[0]*(N+1) for i in range(N+1)]
    dp = [0]*(N)
    for i in range(N):
        k = i
        b = a.copy()
        for j in range(N):
            print(b[k])
            dp[i] += b[k]* pow(-1,j)
            if k==0:
                del b[0]
            elif k==len(b)-1:
                del b[len(b)-1]
                k = len(b)-1
            else:
                if b[k+1] >= b[k-1]:
                    del b[k]
                else:
                    del b[k]
                    k = k-1
        print()
    
    print(dp)

    if len(a)%2==0:
        dp = [dp[i]*-1 for i in range(N)]

    print(max(dp))
                    
# a = [10,80,90,30]
a = [4,2,9,7,1,5]
# このパタンが望んだやつじゃないので上手く行かなかった
N = len(a)

solve(N,a)