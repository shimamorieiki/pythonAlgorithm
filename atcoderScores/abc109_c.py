# 数直線上に N 個の都市があり、i 番目の都市は座標 xiにあります。
# あなたの目的は、これら全ての都市を 1 度以上訪れることです。
# あなたは、はじめに正整数 D を設定します。
# その後、あなたは座標 X から出発し、以下の移動 1、移動 2 を好きなだけ行います。
# 移動 1: 座標 y から座標 y+D に移動する
# 移動 2: 座標 y から座標 y−D に移動する

# 全ての都市を 1 度以上訪れることのできる D の最大値を求めてください。
# ここで、都市を訪れるとは、その都市のある座標に移動することです。
# 制約
# 入力はすべて整数である
# 1≤N≤10^5
# 1≤X≤10^9
# 1≤xi≤10^9
# xiはすべて異なる
# x1,x2,...,xN≠X

# 3 3
# 1 7 11

# 2

import math

N,G = map(int,input().split(" "))
a = list(map(int,input().split(" ")))

a = sorted(list(set([abs(i - G) for i in a])))

for i in range(len(a)-1):
    a[i+1] = math.gcd(a[i+1],a[i])
print(a[-1])

# 基準の数と目的地の差の最大公約数を求めればいいんだと思う
# 一番簡単なのは N*N で回せると思うけどだめっぽいな
# GCDの計算量はいくつなんだろう N*(GCDの計算量)
# GCDの実装を考えてたから時間を無駄にしてしまった
# math.gcdでライブラリにあった
# AC 25
