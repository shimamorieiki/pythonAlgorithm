# 自己ループと二重辺を含まない N 頂点 M 辺の重み付き無向連結グラフが与えられます。
# i(1≦i≦M) 番目の辺は頂点 ai と頂点 bi を距離 ci で結びます。
# ここで、自己ループは ai=bi(1≦i≦M) となる辺のことを表します。
# また、二重辺は (ai,bi)=(aj,bj) または (ai,bi)=(bj,aj)(1≦i<j≦M) となる辺のことを表します。
# 連結グラフは、どの異なる 2 頂点間にも経路が存在するグラフのことを表します。
# どの異なる 2 頂点間の、どの最短経路にも含まれない辺の数を求めてください。
# 制約
# 2≦N≦100
# N−1≦M≦min(N(N−1)/2,1000)
# 1≦ai,bi≦N
# 1≦ci≦1000
# ciは整数である。
# 与えられるグラフは自己ループと二重辺を含まない。
# 与えられるグラフは連結である。

# 3 3
# 1 2 1
# 1 3 1
# 2 3 3

# 1
import math
N = 3
M = 3
a = [[0, 0, 0, 0], [0, 0, 1, 1], [0, 1, 0, 3], [0, 1, 3, 0]]

# N,M = map(int,input().split(" "))
# a = [[0]*(N+1) for i in range(N+1)]
# for i in range(M):
#     x,y,v = map(int,input().split(" "))
#     a[x][y] = v
#     a[y][x] = v
# print(a)

f = [math.inf]*(N+1) # スタートからその道にたどり着くまでの現段階での最短経路
# 今回は連結なのですべての道を通れるということでいいんだと思う
def shortest(v1,v2):
    global f,a
    # 最短経路で進んだときの経路を出力する
    # 距離重み付きだから最短経路 != 通る頂点数最小
    # ダイクストラ法？
    if v1 == v2:
        return 0
    for i in range(1,len(a[v1])):
        if a[v1][i] != 0:
            f[i] = min(f[v1] + a[v1][i],f[i])
            shortest(i,v2)

s = 1
g = 2
f[s] = 0
shortest(s,g)
print(f)
# 方針としてはダイクストラで最短経路出す ワーシャルフロイド？
# そのそれぞれの経路について通った道を列挙して最初のグラフをコピーした配列に加算する
# その時にもとと同じグラフに加算すると重みの値が変化するのでだめ
# 一回も加算されていない辺の個数を数える
# 方針はわかったが実装が重そうなのでもう少ししてから考える
# AC 解答見た
