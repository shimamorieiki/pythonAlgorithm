# N 個の足場があります。
#  足場には 1,2,…,N と番号が振られています。
#  各 i (1≤i≤N) について、足場 i の高さは hiです。
# 最初、足場 1にカエルがいます。 
# カエルは次の行動を何回か繰り返し、足場 Nまで辿り着こうとしています。
# 足場 iにいるとき、足場 i+1,i+2,…,i+K のどれかへジャンプする。
#  このとき、ジャンプ先の足場を j とすると、コスト |hi−hj|を支払う。
# カエルが足場 Nに辿り着くまでに支払うコストの総和の最小値を求めてください。

# dp[i] 足場iにいるときにそこに移動するまでにかかった最小コスト
# dp[i] = min (dp[i-1] + |hi-hi-1| , dp[i-2| + |hi-hi-2| , dp[i-3] + |hi-hi-3| , ... , dp[i-k] + |hi-hi-k|)
# これは 1~K でループを回せば解ける気もするが計算量が多そう
# 2≤N≤10^5
# 1≤K≤100
# 1≤hi≤10^4
# この方針だと計算量はO(NK)
# これでいいらしい

def solve(n,k,h):
    f_inf = float('inf')
    dp = [f_inf]*(n+1)
    dp[1] = 0
    for i in range(2,n+1):
        for j in range(1,min(k+1,i)):
            if dp[i-j]+abs(h[i-j-1]-h[i-1]) <= dp[i]:
                dp[i] = dp[i-j]+abs(h[i-j-1]-h[i-1])
    print(dp[n])

h = [40,10,20,70,80,10,20,70,80,60]
k = 4
n = len(h)
solve(n,k,h)
